/**
 * ==========================================================================================
 * Problem: 301. Remove Invalid Parentheses
 * Link: https://leetcode.com/problems/remove-invalid-parentheses/
 * Difficulty: Hard
 * Tags: String, Backtracking, Breadth-First Search (BFS)
 * Constraints: 1 <= s.length <= 25, at most 20 parentheses.
 * ==========================================================================================
 *
 * PROBLEM SUMMARY:
 * Given a string `s` of parentheses and letters, remove the MINIMUM number of invalid
 * parentheses to make the string valid. Return ALL unique valid strings.
 *
 * Example: "()())()" -> ["(())()", "()()()"]
 * Example: ")(" -> [""]
 *
 * ------------------------------------------------------------------------------------------
 * CORE MODELING (State Space Search):
 * This is fundamentally a search problem. We are exploring the "space" of all possible
 * strings generated by removing characters from `s`.
 *
 * 1. A state is a string.
 * 2. A transition is removing one parenthesis.
 * 3. We want the shortest path (minimum removals) to a valid state.
 *
 * EVOLUTION OF SOLUTION:
 * 1. Brute Force Backtracking: Try removing every subset. Keep track of the minimum removals
 * found globally. (Too slow, explores too deep).
 * 2. BFS: Level-order search. Level 0 is removing 0 chars, Level 1 is removing 1 char.
 * The first level where we find valid strings guarantees minimum removals.
 * 3. Optimized DFS: Instead of blind search, calculate *exactly* how many '(' and ')'
 * are misplaced first. Then use DFS to remove exactly that many, pruning early.
 * ==========================================================================================
 */

#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <unordered_set>
#include <algorithm>

using namespace std;

class Solution {
private:
    // Helper function used across all approaches
    bool isValid(const string& s) {
        int balance = 0;
        for (char c : s) {
            if (c == '(') balance++;
            else if (c == ')') balance--;
            if (balance < 0) return false; // More ')' than '(' at this point
        }
        return balance == 0;
    }

public:
    /**
     * ==================================================================================
     * APPROACH 1: BRUTE FORCE BACKTRACKING (Conceptual Baseline)
     * Time Complexity: O(N * 2^N)
     * Space Complexity: O(N * 2^N) for call stack and storing results
     * ==================================================================================
     * WHY IT EXISTS:
     * - To understand the sheer size of the search space.
     * - We branch on every character: Keep it OR Remove it.
     * - We must track the `minRemovals` globally because DFS dives deep before checking width.
     */
    void backtrack_brute(string current, int index, int removals, int& minRemovals, unordered_set<string>& resultSet) {
        if (index == current.size()) {
            if (isValid(current)) {
                if (removals < minRemovals) {
                    resultSet.clear();
                    minRemovals = removals;
                }
                if (removals == minRemovals) {
                    resultSet.insert(current);
                }
            }
            return;
        }

        char c = current[index];

        // Option 1: Keep the character
        backtrack_brute(current, index + 1, removals, minRemovals, resultSet);

        // Option 2: Remove the character (only if it's a parenthesis)
        if (c == '(' || c == ')') {
            string next_str = current;
            next_str.erase(index, 1);
            // Notice index doesn't increment because string shifted left
            backtrack_brute(next_str, index, removals + 1, minRemovals, resultSet);
        }
    }

    vector<string> removeInvalidParentheses_Brute(string s) {
        unordered_set<string> resultSet;
        int minRemovals = INT_MAX;
        backtrack_brute(s, 0, 0, minRemovals, resultSet);
        return vector<string>(resultSet.begin(), resultSet.end());
    }

    /**
     * ==================================================================================
     * APPROACH 2: BREADTH-FIRST SEARCH (The Minimum-Removal Guarantee)
     * Time Complexity: O(N * 2^N) in worst case (though practically faster due to early exit)
     * Space Complexity: O(N * 2^N) for queue and visited set
     * ==================================================================================
     * WHY BFS?
     * - We want the *minimum* number of removals. Minimum changes = Shortest Path.
     * - BFS naturally explores level by level (Level 0: 0 removals, Level 1: 1 removal, etc.).
     * - Once we find valid strings on a level, we stop queuing new levels.
     */
    vector<string> removeInvalidParentheses_BFS(string s) {
        vector<string> result;
        unordered_set<string> visited;
        queue<string> q;

        q.push(s);
        visited.insert(s);
        bool foundValidLevel = false;

        while (!q.empty()) {
            int levelSize = q.size();

            // Process all strings at the current level (same number of removals)
            for (int i = 0; i < levelSize; ++i) {
                string current = q.front();
                q.pop();

                if (isValid(current)) {
                    result.push_back(current);
                    foundValidLevel = true;
                }

                // If we already found valid strings at this level, we don't need to generate
                // strings for the NEXT level (which would have more removals).
                if (foundValidLevel) continue;

                // Generate next level states by removing one parenthesis
                for (int j = 0; j < current.size(); ++j) {
                    if (current[j] != '(' && current[j] != ')') continue;

                    string nextState = current.substr(0, j) + current.substr(j + 1);

                    // Avoid re-processing the same string
                    if (visited.find(nextState) == visited.end()) {
                        visited.insert(nextState);
                        q.push(nextState);
                    }
                }
            }
            // If we found the answer at this level, stop entirely.
            if (foundValidLevel) break;
        }

        return result;
    }

    /**
     * ==================================================================================
     * APPROACH 3: OPTIMIZED DFS WITH PRUNING (Stronger Modeling)
     * Time Complexity: O(2^N) worst case, but practically much faster than BFS.
     * Space Complexity: O(N) for call stack
     * ==================================================================================
     * WHY THIS IS BEST:
     * - BFS generates many invalid states and queues them.
     * - Instead, we can PRE-CALCULATE exactly how many '(' and ')' are invalid.
     * - Then, we use DFS to remove *exactly* that many.
     * - We can prune branches early if we remove too many, or if the string becomes invalid during generation.
     */
    void dfs_optimized(const string& s, int index, int leftRem, int rightRem, string currentPath, int balance, unordered_set<string>& result) {
        // Pruning: Valid strings never have a negative balance
        if (balance < 0) return;

        // Base Case: Reached the end of the original string
        if (index == s.size()) {
            if (leftRem == 0 && rightRem == 0 && balance == 0) {
                result.insert(currentPath);
            }
            return;
        }

        char c = s[index];

        // OPTION 1: REMOVE the current character (if we still need to)
        if (c == '(' && leftRem > 0) {
            dfs_optimized(s, index + 1, leftRem - 1, rightRem, currentPath, balance, result);
        } else if (c == ')' && rightRem > 0) {
            dfs_optimized(s, index + 1, leftRem, rightRem - 1, currentPath, balance, result);
        }

        // OPTION 2: KEEP the current character
        int newBalance = balance;
        if (c == '(') newBalance++;
        else if (c == ')') newBalance--;

        dfs_optimized(s, index + 1, leftRem, rightRem, currentPath + c, newBalance, result);
    }

    vector<string> removeInvalidParentheses(string s) {
        // Step 1: Pre-calculate the minimum removals required
        int leftRem = 0, rightRem = 0;
        for (char c : s) {
            if (c == '(') {
                leftRem++;
            } else if (c == ')') {
                if (leftRem > 0) {
                    leftRem--; // Matches an open bracket
                } else {
                    rightRem++; // Unmatched close bracket
                }
            }
        }

        unordered_set<string> result_set;
        dfs_optimized(s, 0, leftRem, rightRem, "", 0, result_set);

        return vector<string>(result_set.begin(), result_set.end());
    }
};

/**
 * ==================================================================================
 * DRIVER CODE
 * ==================================================================================
 */
int main() {
    Solution sol;

    string s1 = "()())()";
    cout << "Test 1: ()())()\nResult:\n";
    vector<string> res1 = sol.removeInvalidParentheses(s1); // Using the optimal DFS
    for (const string& str : res1) cout << str << "\n";
    cout << "------------\n";

    string s2 = "(a)())()";
    cout << "Test 2: (a)())()\nResult:\n";
    vector<string> res2 = sol.removeInvalidParentheses_BFS(s2); // Testing BFS
    for (const string& str : res2) cout << str << "\n";
    cout << "------------\n";

    return 0;
}
